diff --git a/ambari-server/src/main/java/org/apache/ambari/server/api/predicate/QueryLexer.java b/ambari-server/src/main/java/org/apache/ambari/server/api/predicate/QueryLexer.java
index f767454243..afea2d3071 100644
--- a/ambari-server/src/main/java/org/apache/ambari/server/api/predicate/QueryLexer.java
+++ b/ambari-server/src/main/java/org/apache/ambari/server/api/predicate/QueryLexer.java
@@ -64,12 +64,12 @@ public class QueryLexer {
    * Map of token type to list of valid handlers for next token.
    */
   private static final Map<Token.TYPE, List<TokenHandler>> TOKEN_HANDLERS =
-      new HashMap<Token.TYPE, List<TokenHandler>>();
+    new HashMap<>();
 
   /**
    * Static set of property names to ignore.
    */
-  private static final Set<String> SET_IGNORE = new HashSet<String>();
+  private static final Set<String> SET_IGNORE = new HashSet<>();
 
 
   /**
@@ -78,7 +78,7 @@ public class QueryLexer {
    */
   public QueryLexer() {
     //todo: refactor handler registration
-    List<TokenHandler> listHandlers = new ArrayList<TokenHandler>();
+    List<TokenHandler> listHandlers = new ArrayList<>();
     listHandlers.add(new LogicalUnaryOperatorTokenHandler());
     listHandlers.add(new OpenBracketTokenHandler());
     listHandlers.add(new PropertyOperandTokenHandler());
@@ -87,26 +87,26 @@ public class QueryLexer {
     TOKEN_HANDLERS.put(Token.TYPE.LOGICAL_OPERATOR, listHandlers);
     TOKEN_HANDLERS.put(Token.TYPE.LOGICAL_UNARY_OPERATOR, listHandlers);
 
-    listHandlers= new ArrayList<TokenHandler>();
+    listHandlers= new ArrayList<>();
     listHandlers.add(new RelationalOperatorTokenHandler());
     listHandlers.add(new RelationalOperatorFuncTokenHandler());
     TOKEN_HANDLERS.put(Token.TYPE.PROPERTY_OPERAND, listHandlers);
 
-    listHandlers = new ArrayList<TokenHandler>();
+    listHandlers = new ArrayList<>();
     listHandlers.add(new ValueOperandTokenHandler());
     TOKEN_HANDLERS.put(Token.TYPE.RELATIONAL_OPERATOR, listHandlers);
 
-    listHandlers = new ArrayList<TokenHandler>();
+    listHandlers = new ArrayList<>();
     listHandlers.add(new CloseBracketTokenHandler());
     listHandlers.add(new ComplexValueOperandTokenHandler());
     TOKEN_HANDLERS.put(Token.TYPE.RELATIONAL_OPERATOR_FUNC, listHandlers);
 
-    listHandlers = new ArrayList<TokenHandler>();
+    listHandlers = new ArrayList<>();
     listHandlers.add(new CloseBracketTokenHandler());
     listHandlers.add(new LogicalOperatorTokenHandler());
     TOKEN_HANDLERS.put(Token.TYPE.BRACKET_CLOSE, listHandlers);
 
-    listHandlers = new ArrayList<TokenHandler>(listHandlers);
+    listHandlers = new ArrayList<>(listHandlers);
     // complex value operands can span multiple tokens
     listHandlers.add(0, new ComplexValueOperandTokenHandler());
     TOKEN_HANDLERS.put(Token.TYPE.VALUE_OPERAND, listHandlers);
@@ -170,7 +170,7 @@ public class QueryLexer {
   private List<String> parseStringTokens(String exp) {
     Pattern      pattern       = generatePattern();
     Matcher      matcher       = pattern.matcher(exp);
-    List<String> listStrTokens = new ArrayList<String>();
+    List<String> listStrTokens = new ArrayList<>();
     int pos = 0;
 
     while (matcher.find()) { // while there's a delimiter in the string
@@ -238,7 +238,7 @@ public class QueryLexer {
     /**
      * List of tokens generated by the scan
      */
-    private List<Token> m_listTokens = new ArrayList<Token>();
+    private List<Token> m_listTokens = new ArrayList<>();
 
     /**
      * If non-null, ignore all tokens up to and including this token type.
@@ -248,7 +248,7 @@ public class QueryLexer {
     /**
      * Property names which are to be ignored.
      */
-    private Set<String> m_propertiesToIgnore = new HashSet<String>();
+    private Set<String> m_propertiesToIgnore = new HashSet<>();
 
     /**
      * Bracket score.  This score is the difference between the number of
@@ -264,7 +264,7 @@ public class QueryLexer {
      * tokens and then in subsequent invocations combine/alter/remove/etc
      * these tokens prior to adding them to the context tokens.
      */
-    private Deque<Token> m_intermediateTokens = new ArrayDeque<Token>();
+    private Deque<Token> m_intermediateTokens = new ArrayDeque<>();
 
 
     /**